# 파이썬 문법 공부

* 슬라이싱  
`변수명[시작 인덱스:마지막인덱스:증가값]`  
* 리스트의 곱셈 연산은 기준 리스트에 n을 곱했을 때, 같은 리스트를 n배만큼 늘려준다.  
* 리스트 추가 및 삭제 함수
  * append() : 새로운 값을 기존 리스트의 맨 끝에 추가
  * extend() : 새로운 리스트를 기존 리스트에 추가(덧셈 연산과 같은 효과)
  * insert() : 기존 리스트의 i번째 인덱스에 새로운 값을 추가, i번째 인덱스를 기준으로 뒤쪽 인덱스가 하나씩 밀림
  * remove() : 리스트 내의 특정 값을 삭제
  * del : 특정 인덱스 값을 삭제

* 언패킹
  ```python
  >>>t=[1, 2, 3] # 패킹
  >>>a, b, c = t # 언패킹
  >>>print(t, a, b, c)
  [1, 2, 3] 1 2 3
  ```
* 파이썬은 리스트를 저장할 때 값 자체가 아니라, 값이 위치한 메모리 주소를 저장한다. 또한 다양한 자료형이 하나의 리스트에 들어갈 수 있다.

* 파이썬의 기본(built-in) 오브젝트 중 Falsy 오브젝트는 
  ```
  False
  None
  0, 0.0, 0L, 0j
  ""
  []
  ()
  {}
  이 외의 모든 기본 오브젝트는 Truthy 오브젝트다.
  ```
* `x == y` 는 x와 y의 값이 같은지 검사, `x is y` 는 x와 y의 메모리 주소가 같은지 검사

* 얕은 복사(Shallow Copy) 와 깊은 복사(Deep Copy): 얕은 복사는 원본 객체의 주소값을 복사하는 것이고, 깊은 복사는 참조된 객체 자체를 복사하는 것이다. 
  * copy 모듈의 deepcopy()
  * 기본클래스의 copy() 함수
  * list를 생성할 때 매개변수에 원본 자체를 전달
  * 빈 list를 생성후 extend()의 매개변수에 원본 전달
  * 리스트 슬라이싱
  * for문을 이용한 배열의 요소 복사
  * 주의) 기본클래스의 copy() 함수나 리스트 슬라이싱을 이용한 copy는 리스트가 오브젝트를 포함하고 있으면 해당 오브젝트 요소들은 얕은 복사가 된다.
* join() 메소드는 매개변수에 str 데이터 유형이 필요하다. 따라서 int형 리스트가 있으면 오류를 발생시킨다. 
  ```py
  >>> a = [1,2,3]
  >>> "".join(a)
  Traceback (most recent call last):
  File "<pyshell#1>", line 1, in <module>
    "".join(a)
  TypeError: sequence item 0: expected str instance, int found
  ```
  * int형 리스트를 str형으로 전환하는 두 가지 방법
    ```py
    # 리스트 컴프리헨션
    >>> a = [1,2,3]
    >>> "".join([str(_) for _ in a])
    "123"
    ```
    ```py
    # map 함수
    >>> a = [1,2,3]
    >>> "".join(map(str, a))
    '123'
    ```

* `if __name__ == '__main__': `의 의미
  * `__name__` 은 파이썬의 내장변수인데 파일 안에서 해당 함수를 실행하면 `__name__` 변수에는 `__main__`이라는 값이 담기고, 파일 외부에서 import를 시키면 `__name__` 변수에는 파일, 모듈이름이 담긴다. 따라서 외부에서 import를 시켰을 때 동작시키지 않고 싶은 코드들을 `if __name__ == '__main__'` 안에 넣어주면 실행되지 않는다. 반대로 파이썬 파일을 직접 실행하면 if문으로 간 다음 if문 아래의 코드들을 호출하는 형식으로 사용한다.     

* 가변인수
  ```python
  def asterisk_test(x, y, *args):
          a, b, *c = args
          return x, y, a, b, c
  print(asterisk_test(1,2,3,4,5,6,7,8))
  결과: (1, 2, 3, 4, [5, 6, 7, 8])
  ```
* 자바는 문자열 + 숫자를 출력하면 항상 문자열로 출력을 하게 되는데, 파이썬은 문자열과 숫자의 연산으로 인식하여 덧셈 연산이 실행되지 않는다.

* 리스트 컴프리헨션 
  ```python
  result = [i for i in range(10)] 
  print(result)
  결과: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

  # 필터링
  result = [i for i in range(10) if i % 2 == 0]
  print(result)
  [0, 2, 4, 6, 8]


  result = [i if i % 2 == 0 else 10 for i in range(10)]
  print(result)
  [0, 10, 2, 10, 4, 10, 6, 10, 8, 10]

  # 문법오류
  # result = [i for i in range(10) if i % 2 == 0 else 10]

  # 중첩 반복문
  word_1 = "Hello"
  word_2 = "World" 
  result = [i+j for i in word_1 for j in word_2]
  print(result)
  ['HW', 'Ho', 'Hr', 'Hl', 'Hd', 'eW', 'eo', 'er', 'el', 'ed', 'lW', 'lo', 'lr', 'll', 'ld', 'lW', 'lo', 'lr', 'll', 'ld', 'oW', 'oo', 'or', 'ol', 'od']

  case_1 = ["A", "B", "C"]
  case_2 = ["D", "E", "A"]
  result = [i+j for i in case_1 for j in case_2 if not(i==j)]
  print(result)
  ['AD', 'AE', 'BD', 'BE', 'BA', 'CD', 'CE', 'CA']
  ```
* 일차원 리스트, 이차원 리스트 코드 구분
  ```python
  // 앞의 for문이 먼저 실행
  [i+j for i in case_1 for j in case_2]
  // 뒤의 for문이 먼저 실행 
  [[i+j for i in case_1] for j in case_2]
  ```
* 타입 어노테이션에서 변수나 함수에 추가한 타입 어노테이션이 부정확한다고 해서 경고나 오류가 발생하는 것은 아니라는 것을 주의.

* with문은 자원을 획득하고 사용 후 반납해야 하는 경우 주로 사용한다.
형태는
    ```python
    with EXPRESSION [as VARIABLE]:  
            BLOCK
    ```
* CSV 객체: text 파일 형태로 데이터 처리시 문장 내에 들어가 있는 콤마(,)에 대해 전처리 과정이 필요하다.
  ```python
  import csv
  reader = csv.reader("파일이름",
                      delimiter = ",", quotechar = '"',
                      quoting = csv.QUOTE_ALL)
  ```
  >delimiter는 CSV 파일이 뭘로 나누어져 있는지(\t, ' ', '+' 등)를 나타낸다. quotechar은 묶어야 하는 string을 처리할 때 사용된다. 예를 들어 "Hello, python"과 같은 문자열은 delimiter가 콤마로 되어있는 경우, "Hello"와 "python"으로 나뉘어 지는데 이를 방지할 수 있다. 나뉘면 안되는 데이터를 무엇으로 묶을 건지를 설정할 수 있다. quoting에서는 이 quotechar의 레벨을 결정한다. QUOTE_ALL은 모든 데이터를 자료형에 상관없이 묶고, QUOTE_MINIMAL은 ',' 같은 데이터가 포함된 데이터만 묶는다.
