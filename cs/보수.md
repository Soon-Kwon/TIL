## 10진법
각 자리가 0~9까지 10가지 숫자 + 각 자리는 10의 제곱을 뜻한다  
* 3413 = 3*10^3 + 4*10^2 + 1*10^1 + 3*10^0 : 천의 자리 3과 일의 자리 3은 같은 3이 아니다

## 2진법 

각 자리가 0과 1 두 가지 숫자 + 각 자리는 2의 제곱을 뜻한다  
* 1011(2) = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 11(10)  
* 2진수의 음수 표현법 => 부호비트와 보수법을 이용

* 최상위 비트(MSB: Most Significant Bit)를 부호비트로 사용  
>0 (양수) 0 0 0 0 0 0 0 = 0   
0 (양수) 1 1 1 1 1 1 1 = 127  
1 (음수) 0 0 0 0 0 0 0 = -128  
1 (음수) 1 1 1 1 1 1 1 = -1   

## 보수법
컴퓨터에서는 덧셈과 보수의 개념을 사용하여 뺄셈을 처리한다. n에 대한 m의 보수는 n - m을 의미한다. 

ex) 10에 대한 6의 보수는 4를 이용: 12 - 6 = 2 + (10 - 6) = 2 + (10에 대한 6의 보수 4)  

r진법에서 r의 보수: 10진법에서 10의 보수, 2진법에서 2의 보수

r진법에서 r-1의 보수: 10진법에서 9의 보수, 2진법에서 1의 보수

2진법에서 1의 보수는 1과0의 숫자를 뒤집기만 하면 되니 유용하다

​

십진수 3000의 10의 보수는 7000 (자리올림 발생)

십진수 12345의 9의 보수는 87654 

이진수 0111의 1의 보수는 1000(2)

이진수 0111 의 2의 보수는 ??  두 수를 더하여 자리올림이 발생하는 값

0111(2) + ? = 10000(2)   ? = 1001(2)  

​

2의 보수 = 1의 보수 + 1


<u>1의 보수가 아닌 2의 보수를 사용하는 이유는 
1의 보수에선 0이 2개 생기기 때문에(0과 -0) 1비트 차이가 나게 되기 때문이다.</u>                                                        



## 오버플로우 및 언더플로우

컴퓨터의 수체계로 인해 언더 및 오버 플로우가 발생 

ex) 130(10) 을 byte 자료형에 넣으면 1 0 0 0 0 0 0 1 0 을 -126으로 인식  => 오버플로우 발생 
​  
127에 1을 더하게 되면

01111111[127] + 1 = 10000000[-128]

-128에 1을 빼게 되면

10000000[-128] - 1 = 01111111[127]

​

즉 범위를 벗어나면 최댓값과 최솟값이 연결되어 진행된다.

​


 

​