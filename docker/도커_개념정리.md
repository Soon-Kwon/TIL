# 도커

## ✔ VirtualBox로 네트워크 개념 공부하기(1)

ip a: 리눅스 IP 주소 확인  
mobaxterm: 윈도우용 터미널

apt-get install apache2  
우분투 패키지 매니저   
패키지 이름은 패키지 매니저에 따라 다를 수 있다.   

`yum (-y) install (-y) httpd (-y) -y`: 무인설치시 자동으로 y를 입력해주는 옵션 --> 
아파치 웹서버 설치
		
1. 포트포워드
2. 웹서버 구동: 
systemctl start httpd
3. 방화벽 설정:
systemctl status firewalld	  

`systemctl enable httpd`: 시작시 자동으로 구동하도록 등록(start는 안시켜줌)  
`systemctl disable firewalld`: 시작시 자동으로 구동시키지 않도록 등록(stop은 안시켜줌)  
`systemctl start httpd`: 서비스 시작   
`systemctl stop httpd`: 서비스 중지   
`systemctl status firewalld`: 서비스 상태 보기   

`systemctl enable --now httpd`: 서비스를 시작하고 자동 시작 등록  
`systemctl disable --now httpd`: 서비스를 중지하고 자동 시작 해제  

.vdi(Virtual Disk Image) --> 내보내기 --> ova(Open Virtualization Format Archive): 압축(이미지라고 생각)

🚫맥북—>VM 네트워크로 SSH 연결 안되는 이유: 맥은 버추얼박스를 설치할 때 네트워크를 자동으로 설치해 주지 않는다. 따라서 따로 설치를 해주고 할당된 IP주소로 접속해야 한다. https://naleejang.tistory.com/167

## ✔ Nat vs Nat network vs Bridge vs Host-Only
0) 정리된 글: https://dksshddl.tistory.com/entry/Ubuntu-VirtualBox-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC
—> 버추얼 박스에서 NAT 네트워크 사용시 10.0.2.15로 아이피가 고정된다. 가상머신이 3개가 NAT으로 설정되었다면 3개 모두 10.0.2.15로 같은 아이피와 각기 다른 네트워크 환경을 가지고 있다. 
의문점1: 윈도우 호스트 IP의 80포트로 들어오는 요청 —> VirtualBox에서 가상머신으로 포트포워딩 —> 접속잘됨. 이와 같은 결과였는데, 3개의 가상머신을 동시에 돌리면서 요청을 보내면 어떤 결과를 나타낼까  
	—> 2개 동시에 돌려도 됨. 둘 다 안되어야한다고 생각했지만 웹서버가  돌아갔는데, 이는 우선순위에 설정에 따른 결과라고 함. 첫 번째 켜진 머신에서만 아이피를 사용하여 돌아가게 되는 것. 
의문점2: virtual box host-onlybox network의 ip
	—> 아래 3번에서 해결

1) NAT 네트워크로 호스트 IP로 포트포워딩 하던걸   
 ex) 192.168.3.52:80 ----> 10.0.2.4:80
랜카드 2개를 사용해서 브릿지 설정을 하게 되면 원래 NAT 네트워크에서 
설정했던 포트포워딩이 먹히지 않는다. NAT 네트워크가 사용되지 않게 된다고 생각하면 된다.

2) DHCP 서버가 없으면(자동으로 IP를 사용하지 못하는 환경에서) 브릿지를 사용할 수 없다. 

3) NAT 방식으로 구성된 가상 머신은 외부 컴퓨터에서 접근이 불가능하지만(이를 가능하게 하는 것이 포트포워딩)
, 인터넷은 사용할 수 있다. 이를 단방향 통신이라 칭하는데, Host-Only 방식은 단방향 통신도 불가능한 구성이다.
그래서 Host-Only 네트워크를 구성하면 Host 혹은 Guest끼리만 통신할 수 있다.
(그래서 Host-Only 어댑터는 게이트웨이가 없는건가?)
Host-Only로 구성된 내부 네트워크 내의 가상머신4에 NAT 연결선을 추가한 후 가상머신4를 게이트웨이로 사용하면,
가상머신 1,2,3에서도 외부네트워크를 사용하게끔 셋팅할 수 있다. 

4) 또 다른 참고블로그: https://wookoa.tistory.com/107

## ✔ VirtualBox로 네트워크 개념 공부하기(2)

* 외부에서 직접 db 서버에 접속할 수 있도록 해서는 안된다. 
web서버(오픈됨)에서 다시 한 번 db 서버로 접속하는 방식 등을 사용해야 한다.

* `sudo apt-get -y update`  
 패키지를 다운받을 곳을 명시해주는 명령어. install하기 전에 항상 실행

* MariaDB 설치시  
 `Disallow root login remotely` : 로컬에서만 루트계정을 사용하게 한다. 보안을 위해 Yes
그러면 mysql -h 10.0.2.5 -u root -p 명령어로 원격에서 mariadb 서버의 mysql에 root로 접근 불가  

MariaDB 설치
```sh
$ sudo apt-get -y update
$ sudo apt-get -y install mariadb-server
$ sudo mysql_secure_installation
$ sudo vi /etc/mysql/mariadb.conf.d/50-server.cnf
# bind-address            = 127.0.0.1

$ sudo systemctl restart mysql
$ sudo mysql -u root -p
CREATE USER 'wpuser'@'%' IDENTIFIED BY 'wppass';
CREATE DATABASE IF NOT EXISTS wordpress;
GRANT ALL PRIVILEGES ON wordpress.* TO 'wpuser'@'%';
quit

워드프레스 설치
$ wget https://ko.wordpress.org/wordpress-4.8.2-ko_KR.zip
$ yum install -y httpd php php-mysql php-gd php-mbstring wget unzip
$ cd /var/www/html
$ unzip /root/wordpress-4.8.2-ko_KR.zip
$ chown -R apache:apache wordpress
$ setenforce 0 # 웹서버가 꺼졌다가 다시 켜지면 SELinux가 살아나기 때문에 영구적으로 disable 시켜주는 방법을 선택해야한다. 이는 아래 명령어로 해결한다.
$ vi /etc/selinux/config  # SELINUX=disabled로 수정하면 된다. 
$ systemctl restart httpd
# 웹브라우저 http://본인 ip/wordpress
```

## ✔ 도커 개념정리

물리서버 > 가상서버 > 인스턴스(클라우드) > 컨테이너 > 서버리스

CI/CD
Integration
Deployment(+Delivery)

BaseImage: 커널x, OSx, 단순한 명령어, 라이브러리, 의존성 파일들만 있음. 호스트 OS의 커널기능을 공유해서 이용 
ex) 우분투에서 필요한 명령어(ex.apt-get), CentOS(ex.yum) 정도만 모아놓음.

Docker 이미지: 1) Docker 컨테이너를 구성하는 파일 시스템 + 실행할 애플리케이션 설정 => 컨테이너를 생성하는 탬플릿
	     2) 패키징 된 소스코드 	
Docker 컨테이너: Dokcer 이미지가 실행된 상태 

Docker 라이프사이클
create + start => run

Docker 엔진을 설치하면 도커 호스트가 되는 것이다. 

### docker 설치
(sed옵션 정리: https://blog.naver.com/int_s/220483567708)

`curl https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker.sh 
yum -y install bash-completion`
==> tab 자동완성 활성화
`curl https://download.docker.com/linux/centos/docker-ce.repo -o /etc/yum.repos.d/docker-ce.repo`  ==> 도커 리포지토리가 yum 리포지토리에 등록이 된다.  
`sed -i -e "s/enabled=1/enabled=0/g" /etc/yum.repos.d/docker-ce.repo` ==> 위 파일의 enabled=1과 일치하는 문자를 enabled=0로 치환  
`yum --enablerepo=docker-ce-stable -y install docker-ce-19.03.15-3.el7`  
`systemctl enable --now docker`

## ✔ 명령어들
`docker search nginx`: Docker Hub에서 이미지 검색  
`docker image ls`: 현재 도커 호스트 안에 이미지의 리스트를 검색  
* 도커에서의 생략 표현  
docker images = docker image ls   
docker (image, container 등 생략가능) inspect test_commit:v1.0  
docker (image, container 등 생략가능) start webserver   

`docker image pull nginx`: Docker Hub에서 이미지 가져오기   
`docker image inspect --format="{{.Os}}" nginx`: 하나 이상의 이미지에 대한 자세한 정보 표시, format 옵션은 원하는 정보만 출력  
`docker container create -p 80:80 --name webserver nginx`: 호스트포트:컨테이너포트로 포트포워딩, --name은 컨테이너 이름, 마지막은 사용할 이미지  
`docker container start webserver`: 컨테이너 시작  
`docker container stop webserver`: 컨테이너 정지  
`docker container rm -f webserver`: 컨테이너 삭제, 원래는 stop하고 rm해야되는데 운영중에 있는 컨테이너도 삭제할 수 있다.  
* 도커 컨테이너 포트번호, 이름(—name)은 unique 해야한다.   

## `docker container run [옵션] 이미지[:태그][인수]`

옵션
```
--publish, -p : 포트포워딩 
--detach, -d : 백그라운드에서 실행한다
--interactive, -i: 표준 입력을 연다  
--tty, -t: 터미널을 사용한다  
```

사용예시  
1. `docker container run --name test_cal centos /bin/cal`   
사용된 /bin/cal 인수는 생성된 centos 컨테이너 안에서 명령을 실행 후 도커 호스트에게 결과를 내보내준다.
2. `docker container run -it --name test_bash centos /bin/bash`  
-it와 /bin/bash를 함께 써야 컨테이너 안으로 들어간다. -i만 입력하면 터미널 환경이 아닌 환경에서 /bin/bash가 실행되고,
-t만 입력하면 입력이 되지 않아 아무것도 할 수 없어진다. /bin/bash는 입력하지 않아도 쉘로 접속은 된다. 그리고 해당 컨테이너를 빠져나오면
컨테이너가 종료된다. 즉 일시적으로 이용한 것이다.   
`docker container run -it --name mysql_client mysql mysql -h 192.168.3.116 -u wpuser -p`
3. 백그라운드 실행  
`docker container run -d --name test_ping centos /bin/ping localhost` : d 옵션
4. 컨테이너 접속 포트 설정  
`docker container run -d -p 8080:80 --name test_port nginx`
`docker container run -d -P nginx ` => 포트번호와 컨테이너 이름을 랜덤하게 부여한다. 
5. 컨테이너 상태  
`docker container stats test_port ` 

docker엔진이 자동으로 cpu와 memory를 할당해주는데, 이를 수동으로 셋팅하는 명령:  
`docker container run -d -p 8181:80 --cpus 1 --memory=256m --name test_resource nginx`   
-> memory=값 또는 memory 값으로 사용가능

## ✔컨테이너 디렉터리 공유  

`docker volume create test_vol` : 볼륨 생성     
그럼 만들어진 볼륨 test_vol의 경로가 어디있을까?      
`docker volume inspect test_vol`     
결과: (생략) "Mountpoint": "/var/lib/docker/volumes/test_vol/_data" (생략)  
특정 경로로 볼륨을 만드는 방법은 아직 없다고 한다.   
`docker run -d -p 9898:80 --cpu-shares 256 --memory 128m --volume test_vol:/usr/share/nginx/html --name volume-container9 nginx`    
```sh
# 기존상황: 컨테이너가 삭제되면 컨테이너 안의 데이터들도 사라져버린다 
docker container exec -it test_resource /bin/bash
cd /usr/share/nginx/html(nginx)
echo "<h1>soon kwon</h1>" > index.html  
docker container rm -f test_resource

# Persistent volume(=스토리지)인 상황  
docker container run -d -p 8282:80 --cpus 1 --memory 256m -v /tmp:/usr/share/nginx/html --name volume-container nginx  
# /tmp(도커 호스트):/usr/share/nginx/html(컨테이너 폴더) --> 마운트 개념  
``` 

컨테이너 리스트 표시    
`docker container ls -a -f name=test`      
`docker ps -a -q -f name=test`: 컨테이너는 프로세스와 같은 의미. f로 이름이 test인 컨테이너를 검색. -q로 ID만 보이게.        

동작중인 컨테이너 연결    
attach: 내가 운영중인 컨테이너 중에서 /bin/bash가 실행되고 있는 컨테이너에만 연결할 수 있다.     
`docker container attach 컨테이너이름`       
해당 쉘에서 나오기위해 exit를 입력하면 컨테이너가 죽어버린다.  
ctrl+p와 ctrl+q를 입력하면 read escape sequence라는 메시지와 함께 쉘을 빠져나오며 
컨테이너가 살아있는 상태인 것을 확인할 수 있다.

## ✔ 동작중인 컨테이너에서 프로세스 실행  
기본구문: `docker container exec [옵션] <컨테이너> <실행명령> [인수]`  
사용예시: `docker container exec (-it) test_bash /bin/echo "Hello World"`  
`docker container exec (-it) test_bash /bin/yum install -y mysql`  
컨테이너 안에서 터미널을 사용할 것이 아니기 때문에 -it 옵션은 생략해도 된다. 반면 mysql과 같은 명령어는 필요하다.
`docker container exec -it test_bash mysql -h 192.168.3.116 -u wpuser -p`  
인수의 '/bin/bash'에서 '/bin/'을 생략해도 된다.  
`docker container exec -it test_bash bash`  


컨테이너가 생성되면 포트넘버를 수정/변경 불가하다.   
컨테이너를 commit하여 image를 만들고 이 이미지를 가지고 다시 컨테이너를 만들어서 포트넘버를 부여하는 방법이 있다.

컨테이너 안의 파일을 복사  
`docker container cp  webserver:/usr/share/nginx/html/index.html ./index.html`  

파일 수정해서 다시 컨테이너 안으로 복사된 내용 전달   
`docker container cp ./index.html webserver:/usr/share/nginx/html/index.html`   
(!참고: 도커 환경이 아닌 서버끼리 파일 통신은 scp aws.tar root@192.168.3.110:/root 이런식으로 한다.)    
`docker container cp ./html webserver:/usr/share/nginx`   
(!참고: tar -xvf aws.tar -C html/는 html폴더에 aws.tar 압축이 풀린 파일들을 넣겠다.   
 x: extract, v: verbosely...압축 풀린 파일들을 보여주는 옵션, f: archive file)  

컨테이너와 원본 이미지의 차이점 확인   
`docker container diff 컨테이너이름` 

## ✔ 컨테이너를 이미지로 만들기  
`docker container commit [옵션] 컨테이너 이미지이름[:태그]`  
`docker container commit -a "soon<soon@example.com>" -m "NICE TO MEET YOU" test_port test_commit:v1.0`  

이미지 정보 보기  
`docker image inspect test_commit:v1.0`  
`docker image inspect test_commit:v1.0 | grep Author`  

(!참고: sudo없이 docker를 이용하는 명령어)    
sudo usermod -a -G docker soon 후 재접속: G로 언급된 그룹에 soon유저를 기존에 속한 그룹에서 삭제하지 않고 G 그룹에 사용자를 추가한다.    

컨테이너 이미지 저장  
보통은 도커 허브에 올리는 것이 일반적이지만 인터넷 환경이 안되거나 하는 상황에서 쓰임  
`docker image save [옵션] <저장 파일명> [이미지이름] `  
`docker image save -o test_commit.tar test_commit:v1.0: o는 write to a file, instead of STDOUT`  

tar 이미지 불러오기
`scp test_commit.tar soon@192.168.3.116:/home/soon`: 테스터 환경에 tar 파일 보내기       

테스터 환경에서 이미지 tar 파일로 이미지 생성   
`docker image load -i test_commit.tar` : i옵션은 Read from tar archive file, instead of STDIN  

## ✔ Docker 네트워크 
eth0 --> enp0s3: 가상의 랜카드  
docker0: DHCP, Port Forward의 기능을 수행하는 가상의 브릿지. 컨테이너는 docker0의 172.17.0.1를 게이트웨이로 한다.  
veth: 가상의 네트워크 인터페이스  

도커 호스트의 veth  
29: veth69c9dd3@if28  
	  
↕ (28-28 링크됨)  
	  
centOS 이미지 컨테이너 안에서 ip a로 얻은 정보   
28: eth0@if29  
  
### Docker 네트워크 생성 및 삭제  
`docker network create [옵션] 네트워크이름`  

옵션  
-d: 네트워크 브리지 또는 오버레이   
--ip-range: 컨테이너에 할당하는 IP주소의 범위 지정  
--subnet: 서브넷을 CIDR 형식으로 지정  

사용예시  
`docker network create -d bridge --subnet 192.168.123.0/24 --ip-range 192.168.123.0/24 test_bridge`  
`docker network create -d bridge my_bridge` : 도커 엔진이 자동으로 네트워크 만들어준다.  
`docker network inspect my_brige`: 상세한 정보를 볼 수 있다.  
Docker 네트워크 연결  
`docker network connect test_bridge 컨테이너이름`  
Docker 네트워크 연결끊기    
`docker network disconnect test_bridge 컨테이너이름 `

✅ 브리지 네트워크를 따로 만들어 주는 이유 --> 컨테이너 이름간에 통신을 할 수 있다.
docker0(172.17.0.1) 브리지는 이러한 기능을 할 수 없다!!  
  
그럼 컨테이너를 생성할 때부터 docker0 네트워크를 이용하지 않고 내가 만든 네트워크를 만들 때  
`docker container run -d --name test1 --network test_bridge -p 8080:80 nginx`  
`docker container run -d --name test2 --network test_bridge -p 8080:80 nginx`  
exec -it 명령으로 서로 ping test1, pint test2 명령어를 입력하면 컨테이너 이름으로 통신 가능해지는 것을 볼 수 있다.  

### Docker 오브젝트 삭제  
`docker container prune`      
`docker image prune -a`: 사용하고 있지 않은 이미지 모두 삭제            
`docker rm -f test_b test_a`: 컨테이너 이름으로 지우기          
`docker rm -f b5f3 d020`: 컨테이너 ID로 지우기     
`docker rm -f $(docker ps -a -q)`: run 중인 컨테이너를 포함해서 전체 컨테이너 삭제     
`docker rmi -f $(docker images -q)`: run 중인 컨테이너를 포함해서 전체 컨테이너 삭제

## ✔ 도커파일 실습 

### 수동으로 도커 dbserver 컨테이너 실행

```sh
# 처음 컨테이너를 만들 때 설정하는 값들은 변경이 제한적이기 때문에 처음 만들 때 잘 만들자. /db 폴더는 없으면 자동으로 생성된다.
docker run -it -d -p 3306:3306 --name dbserver --network my_bridge -v /db:/var/lib/mysql [--workdir /var/lib/mysql --restart always] ubuntu:16.04
docker exec -it dbserver bash # 앞에서 설정한 workdir 때문에 들어가자마자 경로가 /var/lib/mysql이 된다.
sed -i 's/archive.ubuntu.com/ftp.daumkakao.com/g' /etc/apt/sources.list # 가까운 저장소로 설정
apt-get update && apt-get install mariadb-server -y # &&는 앞의 명령어가 성공한 경우 다음 명령어를 실행 cf) &는 명령어를 백그라운드로 동작시킬 때 사용
sed -i 's/bind-address/#bind-address/g' /etc/mysql/mariadb.conf.d/50-server.cnf
/etc/init.d/mysql start
mysql_secure_installation
mysql -u root -p
CREATE USER 'wpuser'@'%' IDENTIFIED BY 'wppass';
CREATE DATABASE IF NOT EXISTS wordpress;
GRANT ALL PRIVILEGES ON wordpress.* TO 'wpuser'@'%';
quit
``` 

### 수동으로 도커 webserver 컨테이너 실행

```sh
docker run -itd -p 80:80 --name webserver --network my_network -v /web:/var/www/html -w /var/www/html centos:7
docker exec -it webserver bash
yum install -y httpd php php-mysql php-gd php-mbstring wget unzip mysql
wget https://ko.wordpress.org/wordpress-4.8.2-ko_KR.zip
cd /var/www/html
unzip /wordpress-4.8.2-ko_KR.zip
cp -r wordpress/* . # ip주소/wordpress가 아닌 루트경로로 접근하기 위해 설정
chown -R apache:apache /var/www/html
httpd &
setenforce 0
######################################
docker commit webserver webserver:v1.0
docker commit dbserver dbserver:v1.0

docker save -o webserver.tar webserver:v1.0
docker save -o dbserver.tar dbserver:v1.0

scp webserver.tar dbserver.tar soon@192.168.3.116:/home/soon

docker load -i webserver.tar
docker load -i dbserver.tar
```

### 도커 dbserver 컨테이너 실행